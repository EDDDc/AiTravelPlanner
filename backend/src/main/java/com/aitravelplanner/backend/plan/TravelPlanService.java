package com.aitravelplanner.backend.plan;

import com.aitravelplanner.backend.plan.dto.ActivityDto;
import com.aitravelplanner.backend.plan.dto.DayPlanDto;
import com.aitravelplanner.backend.plan.dto.TravelPlanCreateRequest;
import com.aitravelplanner.backend.plan.dto.TravelPlanDetailDto;
import com.aitravelplanner.backend.plan.dto.TravelPlanSummaryDto;
import com.aitravelplanner.backend.user.User;
import com.aitravelplanner.backend.user.UserNotFoundException;
import com.aitravelplanner.backend.user.UserRepository;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.transaction.Transactional;
import java.lang.reflect.Array;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class TravelPlanService {

  private static final Logger log = LoggerFactory.getLogger(TravelPlanService.class);
  private static final TypeReference<Map<String, Object>> PREFERENCES_TYPE =
      new TypeReference<>() {};

  private final TravelPlanRepository travelPlanRepository;
  private final DayPlanRepository dayPlanRepository;
  private final ActivityRepository activityRepository;
  private final UserRepository userRepository;
  private final ObjectMapper objectMapper;

  @Transactional
  public TravelPlanDetailDto createPlan(UUID userId, TravelPlanCreateRequest request) {
    User user =
        userRepository.findById(userId).orElseThrow(() -> new UserNotFoundException(userId));

    TravelPlan plan = new TravelPlan();
    plan.setUser(user);
    plan.setTitle(request.getTitle());
    plan.setDestinations(
        request.getDestinations() != null
            ? new ArrayList<>(request.getDestinations())
            : new ArrayList<>());
    plan.setStartDate(request.getStartDate());
    plan.setEndDate(request.getEndDate());
    plan.setBudgetTotal(request.getBudgetTotal());
    plan.setPreferencesJson(
        writePreferencesJson(normalizePreferences(request.getPreferences())));
    plan.setStatus(PlanStatus.DRAFT);

    TravelPlan savedPlan = travelPlanRepository.save(plan);

    if (request.getStartDate() != null && request.getEndDate() != null) {
      LocalDate current = request.getStartDate();
      int dayIndex = 1;
      while (!current.isAfter(request.getEndDate())) {
        DayPlan dayPlan = new DayPlan();
        dayPlan.setPlan(savedPlan);
        dayPlan.setDayIndex(dayIndex);
        dayPlan.setDate(current);
        dayPlan.setSummary("Itinerary placeholder");
        dayPlan.setNotes("Detailed schedule will be generated by AI later.");
        DayPlan persistedDay = dayPlanRepository.save(dayPlan);
        savedPlan.getDays().add(persistedDay);

        Activity activity = new Activity();
        activity.setDayPlan(persistedDay);
        activity.setType(ActivityType.OTHER);
        activity.setName("Pending activity");
        activity.setDescription("AI generated content will appear here.");
        activityRepository.save(activity);
        persistedDay.getActivities().add(activity);

        current = current.plusDays(1);
        dayIndex++;
      }
    }

    return toDetailDto(travelPlanRepository.findById(savedPlan.getId()).orElseThrow());
  }

  @Transactional
  public List<TravelPlanSummaryDto> listPlans(UUID userId) {
    try {
      return travelPlanRepository.findByUserIdOrderByStartDateDesc(userId).stream()
          .map(this::toSummaryDto)
          .collect(Collectors.toList());
    } catch (RuntimeException ex) {
      log.error("Failed to list travel plans for user {}", userId, ex);
      throw ex;
    }
  }

  @Transactional
  public TravelPlanDetailDto getPlan(UUID userId, UUID planId) {
    try {
      TravelPlan plan =
          travelPlanRepository
              .findById(planId)
              .filter(entity -> entity.getUser().getId().equals(userId))
              .orElseThrow(() -> new TravelPlanNotFoundException(planId));
      return toDetailDto(plan);
    } catch (RuntimeException ex) {
      log.error("Failed to load travel plan {} for user {}", planId, userId, ex);
      throw ex;
    }
  }

  private TravelPlanSummaryDto toSummaryDto(TravelPlan plan) {
    return TravelPlanSummaryDto.builder()
        .id(plan.getId())
        .title(plan.getTitle())
        .destinations(
            plan.getDestinations() != null ? List.copyOf(plan.getDestinations()) : List.of())
        .startDate(plan.getStartDate())
        .endDate(plan.getEndDate())
        .budgetTotal(plan.getBudgetTotal())
        .status(plan.getStatus())
        .build();
  }

  private TravelPlanDetailDto toDetailDto(TravelPlan plan) {
    List<DayPlanDto> dayPlanDtos =
        plan.getDays().stream()
            .sorted((a, b) -> Integer.compare(a.getDayIndex(), b.getDayIndex()))
            .map(
                day ->
                    DayPlanDto.builder()
                        .dayIndex(day.getDayIndex())
                        .date(day.getDate())
                        .summary(day.getSummary())
                        .notes(day.getNotes())
                        .activities(
                            day.getActivities().stream()
                                .sorted(
                                    (a1, a2) -> {
                                      if (a1.getStartTime() == null) {
                                        return 1;
                                      }
                                      if (a2.getStartTime() == null) {
                                        return -1;
                                      }
                                      return a1.getStartTime().compareTo(a2.getStartTime());
                                    })
                                .map(this::toActivityDto)
                                .collect(Collectors.toList()))
                        .build())
            .collect(Collectors.toList());

    return TravelPlanDetailDto.builder()
        .id(plan.getId())
        .title(plan.getTitle())
        .destinations(
            plan.getDestinations() != null ? List.copyOf(plan.getDestinations()) : List.of())
        .startDate(plan.getStartDate())
        .endDate(plan.getEndDate())
        .budgetTotal(plan.getBudgetTotal())
        .status(plan.getStatus())
        .preferences(readPreferences(plan.getPreferencesJson()))
        .days(dayPlanDtos)
        .build();
  }

  private ActivityDto toActivityDto(Activity activity) {
    return ActivityDto.builder()
        .type(activity.getType())
        .name(activity.getName())
        .description(activity.getDescription())
        .startTime(activity.getStartTime())
        .endTime(activity.getEndTime())
        .costEstimate(activity.getCostEstimate())
        .latitude(activity.getLocation() != null ? activity.getLocation().getLatitude() : null)
        .longitude(activity.getLocation() != null ? activity.getLocation().getLongitude() : null)
        .address(activity.getLocation() != null ? activity.getLocation().getAddress() : null)
        .build();
  }

  private String writePreferencesJson(Map<String, Object> preferences) {
    if (preferences == null || preferences.isEmpty()) {
      return null;
    }
    try {
      return objectMapper.writeValueAsString(preferences);
    } catch (JsonProcessingException ex) {
      log.warn("Failed to serialize preferences payload, value discarded", ex);
      return null;
    }
  }

  private Map<String, Object> readPreferences(String json) {
    if (json == null || json.isBlank()) {
      return Map.of();
    }
    String content = json.trim();
    try {
      if ((content.startsWith("\"") && content.endsWith("\""))
          || (content.startsWith("'") && content.endsWith("'"))) {
        content = objectMapper.readValue(content, String.class);
      }
      return objectMapper.readValue(content, PREFERENCES_TYPE);
    } catch (JsonProcessingException ex) {
      log.warn("Failed to deserialize preferences json: {}", json, ex);
      return Map.of();
    }
  }

  private Map<String, Object> normalizePreferences(Map<String, Object> source) {
    if (source == null || source.isEmpty()) {
      return null;
    }
    Map<String, Object> normalized = new HashMap<>();
    source.forEach(
        (key, value) -> {
          if (value == null) {
            return;
          }
          if (value instanceof Collection<?> collection) {
            List<String> items =
                collection.stream()
                    .map(item -> item == null ? "" : item.toString().trim())
                    .filter(str -> !str.isEmpty())
                    .collect(Collectors.toList());
            if (!items.isEmpty()) {
              normalized.put(key, String.join("、", items));
            }
            return;
          }
          if (value.getClass().isArray()) {
            int length = Array.getLength(value);
            List<String> items = new ArrayList<>();
            for (int i = 0; i < length; i++) {
              Object element = Array.get(value, i);
              if (element != null) {
                String text = element.toString().trim();
                if (!text.isEmpty()) {
                  items.add(text);
                }
              }
            }
            if (!items.isEmpty()) {
              normalized.put(key, String.join("、", items));
            }
            return;
          }
          String text = value.toString().trim();
          if (!text.isEmpty()) {
            normalized.put(key, text);
          }
        });
    return normalized.isEmpty() ? null : normalized;
  }
}
